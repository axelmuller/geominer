---
title: "Identifying datasets for NURSA"
author: "Axel MÃ¼ller, Kaddis-Lab, City of Hope"
date: '`r format(Sys.time())`'
output:
  html_notebook:
    code_folding: hide
    css: ~/css_styles/rmarkdown.css
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    theme: spacelab
    toc: yes
    toc_float: yes
  html_document:
    toc: yes
---


```{r, message=FALSE, warning=FALSE, include=FALSE}
library(GEOmetadb)
#if(!file.exists('GEOmetadb.sqlite')) getSQLiteFile()
con <- dbConnect(SQLite(),'GEOmetadb.sqlite')
library(GEOquery)

library(tidyverse)
library(magrittr)
library(readr)
library(stringr)
library(RColorBrewer)
library(rcrossref)

library(parallel)

# Calculate the number of cores
no_cores <- detectCores() - 1


```

## Diabetes related datasets

In a first step GEO is queried for all datasets (series) that are potentially 
relevant to diabetes research:

```{r}
 q_gse <- paste("SELECT *",
                    "FROM gse",
                    sep = " ")
#
# ptm <- proc.time()
gse  <- dbGetQuery(con, q_gse)


all_gses <- gse %>% select(gse)

#write_tsv(all_gses, "all_gses.tsv", col_names = TRUE)
# re <- "diabet.*|insuli.*|hyp.*glycemic|langerhans|islet.*"

# new regex based on ontology, see JK's table 1.docx
#re <- "diabet.*|insuli.*|hyp.*glyc(a)*em.*|langerhans|islet.*|glucose.*tolerance"

# it appears that the above regex creates a lot of false positives rerun with stricter
# regex:

re <- "diabet.*|hyp.*glyc(a)*em.*|langerhans|islet.*"


gse_diabetes <- gse %>% 
  filter(grepl(re, summary, ignore.case = TRUE, perl = TRUE) | 
           grepl(re, title, ignore.case = TRUE, perl = TRUE) |
           grepl(re, overall_design, ignore.case = TRUE, perl = TRUE))
diabetes_series_count <- nrow(gse_diabetes)
```

Out of the **`r nrow(gse)`** series that are currently in GEO 
**`r diabetes_series_count` series** that are relevant to diabetic research. 
We want to limit the datasets to those that have data on human, rat, 
or mice. We also want to have data derived from RNA isolates. For this we have 
to have a look at the sample table:

## Filtering by species and limiting to RNA isolates

In this step datasets from organisms other than mouse, rat, or human are 
removed, so are datasets that do not use RNA isolates for the study.

```{r}
q_gsm <- paste("SELECT *",
             "FROM gsm",
             sep = " ")
gsm <- dbGetQuery(con, q_gsm)

species <- c("Homo sapiens", "Mus musculus", "Rattus norvegicus",
             "Rattus rattus",
             "Mus musculus;	Rattus norvegicus",
             "Mus musculus;	Rattus rattus",
             "Homo sapiens;	Mus musculus")
gsm_selection <- gsm %>% 
  filter(grepl("RNA", molecule_ch1)) %>% 
  filter(organism_ch1 %in% species | source_name_ch1 %in% species) %>% 
  select(series_id) %>% 
  distinct()

# join with gse_diabetes 
gse_diabetes %<>% inner_join(gsm_selection, by = c("gse" = "series_id" )) 

# join with entire gsm table to get all the fields added
gse_diabetes %<>% inner_join(gsm, by = c("gse" = "series_id" ))
```
```{r}
all_species <- gsm %>% group_by(organism_ch1) %>% tally()
```

## Filtering by technique

Of the remaining datasets only those generated by high-throughput sequencing
or micro-arrays will be considered.

The techniques employed are:

```{r}
q_gpl <- paste("SELECT *",
               "FROM gpl",
               sep = " ")

gpl <- dbGetQuery(con,q_gpl)

gse_diabetes %<>% inner_join(gpl, by = c("gpl" = "gpl"))

gse_diabetes %>% select(gse, technology) %>% 
  distinct() %>% 
  group_by(technology)%>% 
  tally
```

**UPDATE:**

In addition to looking at the technologies as given in the gpl technology field
it's also possible to have a look at the experiment type field of gse.
It's type.x in the diabetes series matrix.

First we have a look at what type of data we see in this column:

```{r experiment_type_overview}

gse_diabetes %>% 
  distinct(gse, type.x) %>% 
  group_by(type.x) %>% 
  tally %>% 
  arrange(desc(n))

#eto <- ggplot(diabetes_series_matrix, aes(type.x))


```

We will only consider the top two hits, expression profiling by array and by
htp sequencing. This will replace the cut off by technology

```{r}

experiment_type <- c("Expression profiling by array",
                     "Expression profiling by high throughput sequencing")
gse_diabetes <- gse_diabetes %>% filter(type.x %in% experiment_type)
series <- gse_diabetes %>% distinct(gse)
```

**UPDATE**
*This section is replaced by using the experiment type (type.x)*


Being interested in array and htp-sequencing data 
the following filter is applied:

```{r}
techs <- c("high-throughput sequencing", 
           "in situ oligonucleotide", 
           "oligonucleotide beads",
           "spotted oligonucleotide")
# since we applied a filter for RNA samples only we may consider to also
# include spotted DNA/cDNA

gse_diabetes_by_technology <- gse_diabetes %>% filter(technology %in% techs)
series_by_technology <- gse_diabetes_by_technology %>% distinct(gse)
```


## Datasets potentially suited for NURSA

Out of the **`r diabetes_series_count` series**
**`r nrow(series_by_technology)`** fullfill the general criteria 
(**when using the gpl technology field for selection**)
(technology, source organism, source material) for NURSA. They represent 
**`r nrow(gse_diabetes_by_technology)` samples**.

When using the experiment type to filter 
**`r nrow(series)`** series fullfill the criteria,  
**`r nrow(series_by_technology)-nrow(series)`** fewer than when the technology 
field was used. Together they amount to **`r nrow(gse_diabetes)` samples**, 
**`r nrow(gse_diabetes_by_technology)- nrow(gse_diabetes)`** fewer samples.



## Data matrix file

Currently, NURSA requires series with a data matrix file. 
The next step identifies these series.
The following code is used to download all the series matrices 

```{r}
# get list of gses with downloaded matrix file:
# downloaded_matrixfiles <- list.files("/home/axel/projects/hirn/beta_cells/beta_R/matrix_files")
# gses_with_downloaded_matrixfile <- gsub("[-_].*", "", downloaded_matrixfiles)
# gses_with_downloaded_matrixfile <- as.data.frame(gses_with_downloaded_matrixfile)
# gses_with_downloaded_matrixfile %<>% distinct(gse) 
# colnames(gses_with_downloaded_matrixfile) <- "gse"
# gses_with_missing_matrix_files <- anti_join(series, gses_with_downloaded_matrixfile)
# 
# test <- unlist(gses_with_missing_matrix_files)
# lapply(test, 
#        FUN=function(x) 
#        getGEO(x, GSEMatrix = TRUE, 
#                 getGPL = FALSE, 
#                 destdir = "/home/axel/projects/hirn/beta_cells/beta_R/matrix_files")) 
```

The number of files downloaded is:

```{r}
matrix_files <- dir("../matrix_files")

```

`r length(matrix_files)`.

Some series have multiple matrix files associated with them. To identify 
those series with one or more matrix files we can run the following code:

```{r}
# Here is an example of one of the matrix file names:
# GSE24290_series_matrix.txt.gz
gses_with_matrix <- unique(gsub("[_,-].*", "", matrix_files, perl = TRUE))
```

```{r}
# This chunk of code identifies newly added gse and attempts to obtain a 
# series matrix file for each:
# 
all_gses <-  unlist(gse_diabetes %>% select(gse) %>% distinct())
gses_no_matrix <- all_gses[!(all_gses %in% gses_with_matrix)]
# 
# lapply(gses_no_matrix[2],
#        FUN = function(x)
#          getGEO(x, GSEMatrix = TRUE,
#                 getGPL = FALSE,
#                 destdir = "/home/axel/projects/hirn/beta_cells/beta_R/matrix_files"))

#matrix_files <- dir("../matrix_files")
# GSE46023 gave an error, remove this from gses_no_matrix and continue
# GSE75062 also gave an error
# GSE83349 too,
# GSE80178
# gses_no_matrix <- gses_no_matrix[c(-1,-2,-3, -4)]

```
**This leaves `r length(gses_with_matrix)` series to consider.**

```{r}
diabetes_series_matrix <- gse_diabetes %>% 
  filter(gse %in% gses_with_matrix)
```

These **`r length(gses_with_matrix)` series** represent
**`r nrow(diabetes_series_matrix)` samples**.

### Remove sets that don't appear to have data in the GSE-matrix file

```{r}
# dataframe with series matrix stats

# create list of file names including path

path_matrixfile <- lapply(matrix_files, FUN = 
                            function(x) paste("../matrix_files/", x, sep = ""))

# size_matrixfile <- unlist(lapply(path_matrixfile, FUN = 
#                             function(x) utils:::format.object_size(file.info(x)$size, "KB")))

# 
# t2 <- Sys.time()
# comments_lines_matrixfile <- unlist(mclapply(path_matrixfile, FUN = function(x) sum(as.numeric(grepl("!",readLines(x)))), mc.cores = getOption("mc.cores", 12L)))
# mc_comments_time <- Sys.time() - t2
# 
# t1 <- Sys.time()
# lines_matrixfile <- unlist(mclapply(path_matrixfile, FUN = function(x) length(readLines(x)), mc.cores = getOption("mc.cores", 12L)))
# mc_time <- Sys.time() - t1

t3 <- Sys.time()
data_lines_matrixfile <- unlist(mclapply(path_matrixfile, FUN = function(x) sum(as.numeric(!grepl("!",readLines(x)))), mc.cores = getOption("mc.cores", 12L)))
mc_data_lines_time <- Sys.time() - t3
# 
# t4 <- Sys.time()
# data_lines_matrixfile <- unlist(lapply(path_matrixfile, FUN = function(x) sum(as.numeric(!grepl("!",readLines(x))))))
# data_lines_time <- Sys.time() - t4

 # t2 <- Sys.time()
# lines_matrixfile2 <- unlist(lapply(path_matrixfile[1:12], FUN = function(x) length(readLines(x))))
# single_time <- Sys.time() - t2

lines_of_data <- data.frame(matrix_files, data_lines_matrixfile)
colnames(lines_of_data) <- c("matrix_file", "data_lines")


lines_of_data %<>% 
  mutate(gse = gsub("_.*","", matrix_file, perl = TRUE)) 
  
lines_of_data %<>%  
  select(gse, data_lines)

```


## Remove Datasets already in NURSA

Next datasets already in NURSA are removed. A list of datasets in NURSA was 
kindly provided by Dr. Scott Ochsner. 


```{r}
in_nursa <- read_csv("TM_Repositories.csv", col_names = TRUE)
in_nursa_already <- diabetes_series_matrix %>% inner_join(in_nursa)

#diabetes_series_matrix_backup <- diabetes_series_matrix
# diabetes_series_matrix <- diabetes_series_matrix_backup 
diabetes_series_matrix %<>% anti_join(in_nursa) 
```

**`r nrow(in_nursa_already %>% select(gse) %>% distinct())`** of the 
`r length(gses_with_matrix)` series are already in NURSA. This is the 
equivalent of **`r nrow(in_nursa_already)`** samples. 
This leaves **`r nrow(diabetes_series_matrix)`** samples in 
**`r nrow(diabetes_series_matrix %>% select(gse) %>% distinct())`**
series.


## Further Refinement

In a first iteration we will determine all the series that deal with pancreas
samples or cells/cell-lines derived from the pancreas.

```{r}
# regex for pancreas query

re <- "([alpha|beta|delta|gamma].cell)|acinar|ductal|islet|pancr.*" 
#test_pancreas <- c("Alpha cell", "pancreas", "pp", "happy")
#grepl(re, test_pancreas, ignore.case = TRUE, perl = TRUE)

diabetes_series_matrix %<>% 
  mutate(pancreas = ifelse(grepl(re, title.x, perl = TRUE, ignore.case = TRUE) | 
         grepl(re, summary, perl = TRUE, ignore.case = TRUE) | 
         grepl(re, source_name_ch1, perl = TRUE, ignore.case = TRUE) |
         grepl(re, source_name_ch2, perl = TRUE, ignore.case = TRUE) |
         grepl(re, characteristics_ch1, perl = TRUE, ignore.case = TRUE) |
         grepl(re, characteristics_ch2, perl = TRUE, ignore.case = TRUE) |
         grepl(re, description.x, perl = TRUE, ignore.case = TRUE), 1, 0)) %>%  
  inner_join(lines_of_data)
```


```{r}
# get submission year, month, day

diabetes_series_matrix %<>% 
  separate(submission_date, c("year_submission", "months_submission", "day_submission"), sep = "-")

```
```{r}
# remove accidentally duplicoted columns, shouldn't be necessary.
# colnames(diabetes_series_matrix)
# test <- diabetes_series_matrix %>% 
#     setNames(make.names(names(.), unique = TRUE)) %>% 
#     select(-matches("*\\.[1-9]+$"))

dsm <- diabetes_series_matrix %>% 
  filter(data_lines > 100)

nrow(dsm %>% distinct(gse))
```

```{r}
pancreas_hits <- dsm %>% 
  filter(pancreas == 1)

pancreas_hits %>% distinct(gse, overall_design, title.x, summary) 
```


**`r nrow(pancreas_hits %>% select(gse) %>% distinct())`** series 
from the selection are pancreas specific. They represent
**`r nrow(pancreas_hits)`** samples.



```{r}
hs_pancreas <- pancreas_hits %>% 
  filter(organism_ch1 == "Homo sapiens")

nrow(hs_pancreas %>% distinct(gse))
```
```{r}
hs_pancreas %>% distinct(technology, gse) %>% group_by(technology) %>% tally()
```


The following plot displays the number of series and technologies by year.

```{r}
submission_dates <- pancreas_hits %>% 
  select(year_submission, gse, technology) %>% 
  distinct()

year_plot <- ggplot(submission_dates, aes(year_submission))
year_plot + geom_bar(aes(fill = technology)) + 
  scale_fill_brewer(type = "seq", palette = 18) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Find series relevant to the signaling community

Using signaling ontology terms we can identify datasets that mention a term
relevant to signaling in the summary.

```{r}

signaling_ontology <- read_csv("signaling_pathway_terms.csv", col_names = TRUE)
signaling_ontology
```

```{r}
re_sig <- unlist(signaling_ontology %>% select(keyword_regex))
# the sapply funciton yields a logical matrix. by multiplying by 1 it is 
# coerced into a numerical matrix
matches <- as.data.frame(1*(sapply(re_sig, 
                                   grepl,
                                   diabetes_series_matrix$summary, 
                                   ignore.case=TRUE, 
                                   perl = TRUE)))
matches %<>% mutate(combined = rowSums(.)) %>% 
  mutate(hit = ifelse(combined == 0, 0, 1))

diabetes_series_matrix$signaling <- matches$hit
```

```{r}
signaling_hits <- diabetes_series_matrix %>% 
  filter(signaling == 1)
```

**`r nrow(signaling_hits %>% select(gse) %>% distinct())` series** feature a 
signaling related term, representing **`r nrow(signaling_hits)` samples**.

```{r}
#backup_pancreas <- pancreas_hits

pancreas_signaling_hits <- diabetes_series_matrix %>% 
  filter(signaling == 1) %>% 
  filter(pancreas == 1)

#write_tsv(pancreas_hits, "pancreas_hits.tsv", col_names = TRUE)
```

Amongst the pancreas series 
**`r nrow(pancreas_signaling_hits %>% select(gse) %>% distinct())` series** 
and **`r nrow(pancreas_signaling_hits)` samples** that mention the regex 
`r re_sig` have been identified. 

```{r}
#write out dsm table for further analysis

#write_tsv(diabetes_series_matrix, "diabetes_series_matrix_stricterRE.tsv", col_names = TRUE)
```

### Identifying datasets that address the unfolded protein response

```{r}
uprs <- c('\\bupr\\b', 'unfolded protein response', 'grp78', '\\bbip\\b',
             'ire1', '\\bperk\\b', 'atf6', 'tlr\\d+')

, 'toll-like')


re <- paste(uprs, collapse = '|') 
#test_pancreas <- c("Alpha cell", "pancreas", "pp", "happy")
#grepl(re, test_pancreas, ignore.case = TRUE, perl = TRUE)

diabetes_series_matrix %<>% 
  mutate(upr = ifelse(grepl(re, title.x, perl = TRUE, ignore.case = TRUE) | 
         grepl(re, summary, perl = TRUE, ignore.case = TRUE) | 
         grepl(re, source_name_ch1, perl = TRUE, ignore.case = TRUE) |
         grepl(re, source_name_ch2, perl = TRUE, ignore.case = TRUE) |
         grepl(re, characteristics_ch1, perl = TRUE, ignore.case = TRUE) |
         grepl(re, characteristics_ch2, perl = TRUE, ignore.case = TRUE) |
         grepl(re, description.x, perl = TRUE, ignore.case = TRUE), 1, 0))

upr_hits<- diabetes_series_matrix %>% filter(upr == 1) %>% 
  distinct(gse, title.x, type.x, pubmed_id, summary, submission_date.x, 
           pancreas, signaling, data_lines)


#from all gses
#
uprs <- c('\\bupr\\b', 'unfolded protein response', 'grp78', '\\bbip\\b',
             'ire1', '\\bperk\\b', 'atf6')
re <- paste(uprs, collapse = '|') 
gse_diabetes %<>% 
  mutate(upr = ifelse(grepl(re, title, perl = TRUE, ignore.case = TRUE) | 
         grepl(re, summary, perl = TRUE, ignore.case = TRUE),1, 0))

upr_from_all<- gse_diabetes %>% filter(upr == 1) %>% 
  filter(type.x == 'Expression profiling by array' | type.x == 'Expression profiling by high throughput sequencing') %>% 
  distinct(gse, title.x, type.x, pubmed_id, summary, submission_date.x, organism_ch1)


#write_tsv(upr_hits, 'upr_hits.tsv', col_names = TRUE)
write_tsv(upr_from_all, 'upr_from_all.tsv', col_names = TRUE)
```
